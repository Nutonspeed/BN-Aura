/**
 * Smart Inventory Management System
 */

interface InventoryItem {
  itemId: string;
  clinicId: string;
  name: string;
  category: 'skincare_product' | 'medical_supply' | 'equipment';
  currentStock: number;
  reorderPoint: number;
  unitCost: number;
  supplierId: string;
  supplierName: string;
  leadTimeDays: number;
  lastUsageDate: string;
}

interface PurchaseOrder {
  orderId: string;
  clinicId: string;
  supplierId: string;
  supplierName: string;
  orderDate: string;
  status: 'pending' | 'ordered' | 'delivered';
  totalAmount: number;
  items: { itemId: string; quantity: number; unitCost: number }[];
  autoGenerated: boolean;
}

class SmartInventoryManager {
  private static inventory: Map<string, InventoryItem> = new Map();
  private static orders: Map<string, PurchaseOrder> = new Map();

  static addInventoryItem(item: InventoryItem): void {
    this.inventory.set(item.itemId, item);
  }

  static recordUsage(itemId: string, quantity: number): void {
    const item = this.inventory.get(itemId);
    if (!item) throw new Error('Item not found');
    
    item.currentStock = Math.max(0, item.currentStock - quantity);
    item.lastUsageDate = new Date().toISOString();
    this.inventory.set(itemId, item);
    
    if (item.currentStock <= item.reorderPoint) {
      this.generateAutoOrder(item);
    }
  }

  static predictStockOut(itemId: string): { stockOutDate: string; recommendedQuantity: number } {
    const item = this.inventory.get(itemId);
    if (!item) throw new Error('Item not found');
    
    const dailyUsage = 2; // Mock daily usage
    const daysRemaining = Math.floor(item.currentStock / dailyUsage);
    const stockOutDate = new Date(Date.now() + daysRemaining * 24 * 60 * 60 * 1000).toISOString();
    const recommendedQuantity = dailyUsage * (item.leadTimeDays + 7); // Lead time + safety stock
    
    return { stockOutDate, recommendedQuantity };
  }

  static generateAutoOrder(item: InventoryItem): string {
    const orderId = `PO_${Date.now()}`;
    const prediction = this.predictStockOut(item.itemId);
    
    const order: PurchaseOrder = {
      orderId,
      clinicId: item.clinicId,
      supplierId: item.supplierId,
      supplierName: item.supplierName,
      orderDate: new Date().toISOString(),
      status: 'pending',
      totalAmount: prediction.recommendedQuantity * item.unitCost,
      items: [{
        itemId: item.itemId,
        quantity: prediction.recommendedQuantity,
        unitCost: item.unitCost
      }],
      autoGenerated: true
    };
    
    this.orders.set(orderId, order);
    console.log(`ðŸ“¦ Auto-generated order: ${item.name} x${prediction.recommendedQuantity}`);
    return orderId;
  }

  static getInventoryAlerts(clinicId: string): {
    lowStock: InventoryItem[];
    outOfStock: InventoryItem[];
    totalValue: number;
  } {
    const items = Array.from(this.inventory.values()).filter(i => i.clinicId === clinicId);
    
    return {
      lowStock: items.filter(i => i.currentStock > 0 && i.currentStock <= i.reorderPoint),
      outOfStock: items.filter(i => i.currentStock === 0),
      totalValue: items.reduce((sum, i) => sum + (i.currentStock * i.unitCost), 0)
    };
  }

  static getOrders(clinicId?: string): PurchaseOrder[] {
    return Array.from(this.orders.values())
      .filter(order => !clinicId || order.clinicId === clinicId);
  }

  static getInventory(clinicId?: string): InventoryItem[] {
    return Array.from(this.inventory.values())
      .filter(item => !clinicId || item.clinicId === clinicId);
  }
}

export { SmartInventoryManager, type InventoryItem, type PurchaseOrder };
